---
title: "Taxon Harmonization"
author: "Nick Hoffman"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
    highlight: pygment
    keep_md: no
    toc: true
    number_sections: true
    toc_depth: 1
    toc_float: true
    theme: journal
editor_options:
    chunk_output_type: inline
---

<style type="text/css">
h2, h3, h4, h5, h6 {
  counter-reset: section;
}
p {
  font-size:18px;
}

ul {
  font-size:18px;
}

li {
  font-size:18px;
}
table {
   padding: 0;border-collapse: collapse;
   layout: fixed;
   width: 90%; }
table tr {
   border-top: 1px solid #cccccc;
   background-color: white;
   margin: 0;
   padding: 0; }
table tr:nth-child(2n) {
   background-color: #f8f8f8; }
table tr th {
   font-weight: bold;
   border: 1px solid #cccccc;
   margin: 0;
   padding: 6px 13px; }
table tr td {
   border: 1px solid #cccccc;
   margin: 0;
   padding: 6px 13px; }
table tr th :first-child, table tr td :first-child {
   margin-top: 0; }
table tr th :last-child, table tr td :last-child {
   margin-bottom: 0; }
.html-widget {
    margin: auto;
}
</style>

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

When you are using and comparing pollen data from multiple sites, it is important to make sure pollen taxa are named consistently across sites. This process is called taxon harmonization. Throughout this tutorial we will be using <i>Olea</i>, the olive, as an example.

There are a few different reasons why taxon harmonization is important.

1. Taxon names change over time. For example, the African olive once was thought to be its own species, <i>Olea africana</i>. However, with new botanical and molecular information, we now know that it is actually a subspecies, rather than its own species. So the accepted name has now been updated to <i>Olea europaea subsp. cuspidata</i>. Older datasets in Neotoma may refer to the same taxon by its older name.
2. A particular taxon can be identified to varying resolution. For instance, <i>Olea capensis</i> pollen can be identified to a species-level morphotype, but sometimes analysts will only identify it to the genus level. Depending on the nature of your analysis, you may therefore want to aggregate all the <i>Olea capensis</i> pollen in your data to a broader <i>Olea</i> category.
3. Many plant taxa are cosmopolitan. Across a regional or continental synthesis, it isn't obvious how you should deal with the question of splitting and lumping. In the case of <i>Olea</i>, depending on your question, you may want to treat the population from southern Africa as distinct from the east African population - or you may not. This is something you should be intentional about. 

There are multiple good ways to harmonize. It all depends on what best suits the analysis you intend. 

Luckily for us, The African Pollen Database curates a valuable table for assisting in taxa harmonization across African pollen. This guide will walk you through use of the APD taxa harmonization table with a simple example.

## Packages and Data

We'll first load up some packages we're going to be using, and then grab some pollen data to play with from Neotoma.

```{r packages,message=FALSE,warning=FALSE}

library(neotoma2)
library(tidyverse)
library(sf)
library(geojsonsf)
library(httr)
library(jsonlite)
library(stringr)
library(ggplot2)
library(leaflet)
library(tmap)
library(rosm)
library(osmdata)
library(DT)
```

We make a bounding box that encompasses all of Africa. Then we grab all Neotoma sites from that box, and filter for just those datasetids that concern pollen. Then we use the Neotoma2 package to download all of those pollen data.

```{r get-data, warning = FALSE, message = FALSE}
lats = c(38, 38, -36, -36)
lons = c(-18, 52, 52, -18) # Reordered for a rectangle

# Create a data frame with coordinates
coordinates = data.frame(lat = lats, lon = lons)

# Convert to sf object and create a polygon
coordinates_sf = coordinates %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%
  summarise(geometry = st_combine(geometry)) %>%
  st_cast("POLYGON")

# Plot to check
tm_shape(osm.raster(coordinates_sf)) +
  tm_rgb() +
  tm_shape(coordinates_sf) +
  tm_polygons(alpha = 0.5)


coord_json = sf_geojson(coordinates_sf)


altmin = 000 #m

sites = content(GET(paste0("https://api.neotomadb.org/v2.0/data/sites?altmin=",altmin,"&loc=",coord_json,"&limit=9999&offset=0")))$data


idx = 0
for (i in seq(length(sites))) {
  for (j in seq(length(sites[[i]]$collectionunits))) {
    for (k in seq(length(sites[[i]]$collectionunits[[j]]$datasets))) {
    idx = idx + 1
    }
    }
}


sites_mat = matrix(nrow=idx,ncol=11)

idx2 = 0
for (i in seq(length(sites))) {
  for (j in seq(length(sites[[i]]$collectionunits))) {
    for (k in seq(length(sites[[i]]$collectionunits[[j]]$datasets))) {
    idx2 = idx2 + 1
    for (m in seq(5)) {
      if (!is.null(sites[[i]][[m]])) {
        sites_mat[[idx2, m]] = sites[[i]][[m]]
      }
    }
    
     if (!is.null(sites[[i]]$collectionunits[[j]]$handle)) {
        sites_mat[[idx2,6]] = sites[[i]]$collectionunits[[j]]$handle
     }
       if (!is.null(sites[[i]]$collectionunits[[j]]$collectionunit)) {
        sites_mat[[idx2,7]] = sites[[i]]$collectionunits[[j]]$collectionunit
       }
       if (!is.null(sites[[i]]$collectionunits[[j]]$collectionunitid)) {
        sites_mat[[idx2,8]] = sites[[i]]$collectionunits[[j]]$collectionunitid
       }
       if (!is.null(sites[[i]]$collectionunits[[j]]$collectionunittype)) {
        sites_mat[[idx2,9]] = sites[[i]]$collectionunits[[j]]$collectionunittype
       }
       if (!is.null(sites[[i]]$collectionunits[[j]]$dataset[[k]]$datasetid)) {
        sites_mat[[idx2,10]] = sites[[i]]$collectionunits[[j]]$dataset[[k]]$datasetid
       }
       if (!is.null(sites[[i]]$collectionunits[[j]]$dataset[[k]]$datasettype)) {
        sites_mat[[idx2,11]] = sites[[i]]$collectionunits[[j]]$dataset[[k]]$datasettype
       }
    }
  }
}

sites_df = as.data.frame(sites_mat)

names(sites_df) = c("siteid","sitename","sitedescription","geography","altitude","handle","collectionunit","collectionunitid","collectionunittype","datasetid","datasettype")


datasetids = sites_df %>% dplyr::filter(datasettype == "pollen") %>% dplyr::distinct(datasetid)

datasets_neo = get_datasets(as.numeric(datasetids$datasetid),all_data=TRUE)

data = samples(get_downloads(datasets_neo,all_data=TRUE))

```

Now that we have our data, let's grab our harmonization table. That comes from the [African Pollen Database](https://africanpollendatabase.ipsl.fr/)'s website, and you can download it directly through the "download table [.csv]" button on [this page](https://africanpollendatabase.ipsl.fr/#/taxon-dict). 

We'll manipulate the data little bit to make sums of pollen counts by site and age. Then we'll divide every pollen count by the appropriate sum in order to get proportion data. 


```{r part-two, warning = FALSE, message = FALSE}

apd_harmTable = read.csv("APD_dictionnary_export.csv",row.names=NULL,sep=";")


poltots = data %>% left_join(apd_harmTable, by=join_by(variablename == Taxon..original.name.)) %>% group_by(siteid,age) %>% summarize(poltot = sum(value))

pollendata = data  %>% left_join(poltots) %>% group_by(siteid,age,variablename) %>% summarize(prop = value/poltot, lat=lat, elev = elev) %>% left_join(apd_harmTable, by=join_by(variablename == Taxon..original.name.))


```

# <i>Olea capensis</i> elevation shifts

Let's say we're interested in elevation shifts in <i>Olea capensis</i> over time. We can filter our data for just those instances where <i>Olea capensis</i> is greater than 5% of the pollen assemblage with the code below. We filter for when the variablename is "<i>Olea capensis</i>" and when its proportion is greater than 0.05. When I do that in November 2024, I get 127 instances of greater than 5% <i>Olea capensis</i>.

When we plot the elevation of those occurrences over time, we get a plot that shows no clear pattern of elevation change of <i>Olea capensis</i> throughout Africa over the last 20,000 years, since the last ice age.


``` {r partthefifth, warning = FALSE, message = FALSE}
oleacap_noHarm = pollendata %>% dplyr::filter(variablename == "Olea capensis") %>% dplyr::filter(!is.na(prop)) %>%
  dplyr::filter(prop > 0.05)


ggplot() +
  geom_point(mapping=aes(x=age,y=elev),alpha=0.8,color='red',data=oleacap_noHarm) +
  scale_x_reverse(limits=c(20000,0)) +
  scale_y_continuous(name = "elevation (meters)") +
  theme_bw()




```

The story we got from those <i>Olea capensis</i> data seems reliable. But we might be excluding some occurrences of <i>Olea capensis</i> that may have been named slightly differently by different analysts.

```{r part-three, warning = FALSE, message = FALSE}


oleatable = pollendata %>% dplyr::filter(str_detect(variablename,"Olea")) %>%
  dplyr::filter(str_detect(variablename,"capensis")) %>% group_by(variablename) %>% count() %>% left_join(apd_harmTable, by=join_by(variablename == Taxon..original.name.)) %>% arrange(desc(n))
 
datatable(oleatable[c(1,3,2)],rownames=FALSE)

```

Consider the table above that shows all number of occurrences for all the different taxa with the words "Olea" and "capensis" somewhere in them from our dataset, alongside the recommended nomenclature for that taxon from the APD taxon harmonization table. "<i>Olea capensis</i>" is the most commonly used taxon - but there are other categories which we may want include in our analysis. In particular, the taxon is often referred to as "Olea capensis-type" to communicate that the identification is of a pollen morphology that is associated with Olea capensis but may not uniquely identify Olea capensis. The APD considers Olea capensis and Olea capensis-type to be equivalent taxa.   


Let us therefore include this second taxon, <i>Olea capensis-type</i>, in our analysis and see if it makes a difference. We probably also want to include the other three categories here - all variations on the <i>hochstetteri</i> subspecies of <i>Olea capensis</i>. Because <i>Olea capensis</i> pollen cannot be reliably identified to the subspecies resolution, any identification as <i>hochstetteri</i> in pollen likely derives from local knowledge that given the age and location of the <i>Olea capensis</i> pollen, it must be <i>hochstetteri</i>. Since we're doing a broad regional analysis of <i>Olea capensis</i> over time, that fine distinction doesn't matter to us.


We include these new taxa below by filtering for any of the variablenames in our table where their proportion is greater than 0.05. As of November 2024, this search returns 336 occurrences - almost 200 more than our original search !

When we plot these extended data over our old data, we see a clear increase in elevation at the start of the Holocene.

``` {r again}

oleacap_Harm = pollendata %>% dplyr::filter(variablename %in% oleatable$variablename) %>% dplyr::filter(!is.na(prop)) %>%
  dplyr::filter(prop > 0.05)




ggplot() +
    geom_point(mapping=aes(x=age,y=elev),alpha=0.8,color='blue',data=oleacap_Harm) +
    geom_point(mapping=aes(x=age,y=elev),alpha=0.8,color='red',data=oleacap_noHarm) +
  scale_x_reverse(limits=c(20000,0)) +
  theme_bw()



```

# Pollen Analyst Comparison 

Part of the reason there is so much variation in taxon naming is because it is difficult to be completely consistent from person to person and lab to lab. This is another key reason why harmonization matters In this section, we'll compare the taxonomic systems of pollen analysts working near each other.

First we'll grab the entire sampleanalysts table from Neotoma and filter for those pollen analysts who counted pollen from Africa. Then we'll join our table of contacts to our data by siteid.


```{r analysts, warning = FALSE, message = FALSE}


text="sampleanalysts"
analysts = content(GET(paste0('https://api.neotomadb.org/v2.0/data/dbtables/',text,'?count=false&limit=999999&offset=0')))$data

analyst_mat = matrix(nrow = length(analysts),ncol=6)
for (i in seq(length(analysts))) {
  for (j in seq(6)) {
    if (!is.null(analysts[[i]][[j]])) {
      analyst_mat[i,j] = analysts[[i]][[j]]
    }
  }
}

analyst_df = as.data.frame(analyst_mat)

names(analyst_df) = c("analystid","sampleid","contactid","analystorder","recdatecreated","recdatemodified")


distinct_samples = data %>% distinct(sampleid)

filtered_an = analyst_df %>% dplyr::filter(sampleid %in% distinct_samples$sampleid)

```



``` {r nextwel, warning = FALSE, message = FALSE}

#Next, we'll map where these analysts worked, so that we #can compare some who work near each other.

merger = filtered_an %>% left_join(data) %>% group_by(siteid) %>% summarize(siteid=siteid, lat=lat,long=long,contactid=contactid) %>% distinct() %>% st_as_sf(coords=c("long","lat"), crs="WGS84")


#pal <- colorFactor(palette = "Set1", domain = merger$contactid)


#leaflet() %>%
#  addTiles() %>%
#  addCircleMarkers(data = merger, 
#                   radius = 5, 
#                   color = ~pal(contactid), 
#                   fillColor = ~pal(contactid), 
#                   fillOpacity = 0.7, 
#                   stroke = FALSE, 
#                   popup = ~contactid)

```



``` {r lastl, warning = FALSE, message = FALSE}
#Lastly, we'll do a few comparisons of people who worked near each other. Notice how the most abundant taxa for one analyst may be entirely missing for the other. This may be because they simply are naming the same plant taxa differently. 

#picks = merger %>% dplyr::filter(contactid %in% c("1022","15804"))

#people = content(GET("https://api.neotomadb.org/v1.5/data/contacts/1022,15804"))$data

#comparison = data %>% dplyr::filter(siteid %in% picks$siteid) %>% left_join(picks) %>% group_by(contactid,variablename) %>% count() %>% pivot_wider(names_from = contactid,values_from=n)

#datatable(comparison,rownames=FALSE)


#picks2 = merger %>% dplyr::filter(contactid %in% c("16030","16095"))

#people2 = content(GET("https://api.neotomadb.org/v1.5/data/contacts/16030,16095"))$data

#comparison2 = data %>% dplyr::filter(siteid %in% picks2$siteid) %>% left_join(picks2) %>% group_by(contactid,variablename) %>% count() %>% pivot_wider(names_from = contactid,values_from=n)

#datatable(comparison2,rownames=FALSE)




#picks3 = merger %>% dplyr::filter(contactid %in% c("17668","262"))

#people3 = content(GET("https://api.neotomadb.org/v1.5/data/contacts/17668,262"))$data

#comparison3 = data %>% dplyr::filter(siteid %in% picks3$siteid) %>% left_join(picks3) %>% group_by(contactid,variablename) %>% count() %>% pivot_wider(names_from = contactid,values_from=n)

#datatable(comparison3,rownames=FALSE)

```

We're going to do cluster and principal components analyses on our pollen data to see how much distance is engendered by different taxonomic naming practices. We'll filter our new table for just those sites in eastern Africa, so that all the sites we look at will have relatively similar ecologies, and any differences we among analysts will be more likely to derive from different ways of naming.

We pivot our data table wider, making a table where each row corresponds to a particular analyst, and each column to a taxon name. We give a value of 1 to taxa names used by an analyst, and 0 to ones not used by an analyst. Then we cluster with the agglomerative ```hclust()``` method and use prcomp() to make a PCA. 

```{r clusterpollenanalyst}

lats = c(-16, -16, 16, 16)
lons = c(26, 40, 40, 26) # Reordered for a rectangle

# Create a data frame with coordinates
coordinates = data.frame(lat = lats, lon = lons)

# Convert to sf object and create a polygon
coordinates_sf = coordinates %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326) %>%
  summarise(geometry = st_combine(geometry)) %>%
  st_cast("POLYGON")

# Plot to check


merger = ungroup(merger)
merger_east = st_filter(merger,coordinates_sf)

tm_shape(osm.raster(coordinates_sf)) +
  tm_rgb() +
  tm_shape(coordinates_sf) +
  tm_borders(alpha = 0.5) +
  tm_shape(merger_east) +
  tm_dots(col="contactid",size=0.5)

wide_data = data %>% dplyr::filter(siteid %in% merger_east$siteid) %>% left_join(merger) %>% group_by(contactid,variablename) %>% count() %>% pivot_wider(id_cols = contactid, names_from = variablename, values_from = n, values_fill = 0) 

wide_data[,-1][wide_data[,-1] !=0 ] = 1

justvals = wide_data[,-1]
library(factoextra)
#library(mclust)
library(cluster)




allpeople = content(GET(paste0("https://api.neotomadb.org/v1.5/data/contacts/",paste0(wide_data[[1]],collapse=","))))$data

people_mat = matrix(nrow=length(allpeople),ncol=2)

for (i in seq(length(allpeople))) {
  if(!is.null(allpeople[[i]]$contactname)) {
    people_mat[i,1] = allpeople[[i]]$contactname
  }
    if(!is.null(allpeople[[i]]$contactid)) {
    people_mat[i,2] = allpeople[[i]]$contactid
  }
}


people_df = as.data.frame(people_mat)
names(people_df) = c("contactname","contactid")


wide_data = wide_data %>% left_join(people_df)
## hclust
    
      distances = dist(justvals, method = 'euclidean')
    agglomerative_clustering <- hclust(distances, method = 'average')
    
        fviz_dend(agglomerative_clustering, cex = 0.5, k = 3, color_labels_by_k = TRUE, show_labels=TRUE)
    
      
    plot(agglomerative_clustering,labels=wide_data$contactname)

pca = prcomp(justvals)    

wide_data$pc1 = pca$x[,1]
wide_data$pc2 = pca$x[,2]

ggplot(wide_data) + 
  geom_point(mapping=aes(x=pc1,y=pc2)) +
  geom_text(mapping=aes(x=(pc1+0.5),y=(pc2-0.5),label=contactname)) +
  labs(x = "PC1 (22.7%)", y = "PC2 (9.8%)") +
  theme_bw()


ggplot(wide_data) + 
  geom_point(mapping=aes(x=pc1,y=pc2)) +
  geom_text(mapping=aes(x=(pc1+0.2),y=(pc2-0.2),label=contactname)) +
  labs(x = "PC1 (22.7%)", y = "PC2 (9.8%)") +
  scale_x_continuous(limits=c(-1,4)) +
  scale_y_continuous(limits=c(-3,1)) +
  theme_bw()




ggplot(wide_data) + 
  geom_point(mapping=aes(x=pc1,y=pc2)) +
  geom_text(mapping=aes(x=(pc1+0.1),y=(pc2-0.1),label=contactname)) +
  labs(x = "PC1 (22.7%)", y = "PC2 (9.8%)") +
  scale_x_continuous(limits=c(1.6,3.5)) +
  scale_y_continuous(limits=c(-2,-0.6)) +
  theme_bw()

#pc1 biggest loadings
pca$rotation[,1][abs(pca$rotation[,1]) %in% tail(sort(abs(pca$rotation[,1])), 5)] 

#pc2 biggest loadings
pca$rotation[,2][abs(pca$rotation[,2]) %in% tail(sort(abs(pca$rotation[,2])), 5)] 

#pc3 biggest loadings
pca$rotation[,3][abs(pca$rotation[,3]) %in% tail(sort(abs(pca$rotation[,3])), 5)] 

```

Now we repeat our analysis, except that instead of using the original taxa names provided by analysts, we use the recommended nomenclature from the APD. We should see the points converge somehow. In at least one sense, they do: the original wide table has 1452 column names representing different taxa, while the harmonized wide table has only 817 variables representing different taxa. [But other evidence of convergence is hard to see ??]

``` {r more-granular}
wide_data_harm = data %>% dplyr::filter(siteid %in% merger_east$siteid) %>% left_join(merger) %>% left_join(apd_harmTable, by=join_by(variablename == Taxon..original.name.)) %>% group_by(contactid,Taxon..revised.nomenclature.) %>% count() %>% pivot_wider(id_cols = contactid, names_from = Taxon..revised.nomenclature., values_from = n, values_fill = 0) 

wide_data_harm[,-1][wide_data_harm[,-1] !=0 ] = 1

justvals_harm = wide_data_harm[,-1]



wide_data_harm = wide_data_harm %>% left_join(people_df)
## hclust
    
      distances_harm = dist(justvals_harm, method = 'euclidean')
    agglomerative_clustering_harm <- hclust(distances_harm, method = 'average')
    
        fviz_dend(agglomerative_clustering_harm, cex = 0.5, k = 3, color_labels_by_k = TRUE, show_labels=TRUE)
    
      
    plot(agglomerative_clustering_harm,labels=wide_data_harm$contactname)

pca_harm = prcomp(justvals_harm)    

wide_data_harm$pc1 = pca_harm$x[,1]
wide_data_harm$pc2 = pca_harm$x[,2]

ggplot(wide_data_harm) + 
  geom_point(mapping=aes(x=pc1,y=pc2)) +
  geom_text(mapping=aes(x=(pc1+0.5),y=(pc2-0.5),label=contactname)) +
  labs(x = "PC1 (22.9%)", y = "PC2 (9.5%)") +
  theme_bw()


ggplot(wide_data_harm) + 
  geom_point(mapping=aes(x=pc1,y=pc2)) +
  geom_text(mapping=aes(x=(pc1+0.2),y=(pc2-0.2),label=contactname)) +
  labs(x = "PC1 (22.9%)", y = "PC2 (9.5%)") +
  scale_x_continuous(limits=c(-1,4)) +
  scale_y_continuous(limits=c(-3,1)) +
  theme_bw()




ggplot(wide_data_harm) + 
  geom_point(mapping=aes(x=pc1,y=pc2)) +
  geom_text(mapping=aes(x=(pc1+0.1),y=(pc2-0.1),label=contactname)) +
  labs(x = "PC1 (22.9%)", y = "PC2 (9.5%)") +
  scale_x_continuous(limits=c(1.6,3.5)) +
  scale_y_continuous(limits=c(-2,-0.6)) +
  theme_bw()

#pc1 biggest loadings
pca_harm$rotation[,1][abs(pca_harm$rotation[,1]) %in% tail(sort(abs(pca_harm$rotation[,1])), 5)] 

#pc2 biggest loadings
pca_harm$rotation[,2][abs(pca_harm$rotation[,2]) %in% tail(sort(abs(pca_harm$rotation[,2])), 5)] 

#pc3 biggest loadings
pca_harm$rotation[,3][abs(pca_harm$rotation[,3]) %in% tail(sort(abs(pca_harm$rotation[,3])), 5)] 
```
<div class="tocify-extend-page" data-unique="tocify-extend-page" style="height: 0;"></div>